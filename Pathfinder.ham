/*class*/import java.util.Arrays;
import java.lang.Math;

class Pathfinder extends Hamster 
{
	
	static int currX;
	static int currY;
	
	static int targetX;
	static int targetY;
	static int bestX;
	static int bestY;
	
	static double deltaX;
	static double deltaY;
	static double currDist;
	static double bestDist = 200.0;
	
	static boolean done;
	
	static boolean[][] open = new boolean[99][99];
	static boolean[][] closed = new boolean[99][99];
	static int[][] gCost = new int[99][99];
	static int[][] hCost = new int[99][99];
	static int[][] fCost = new int[99][99];
	
	static int[] currentPath;
	
	public static int[] findPath(int nposX, int nposY, int ntargetX, int ntargetY, String[][] newMap)
	{
		
		/*
			
			ARRAYS ARE [Y][X]!!!
			
		*/
		
		currX = nposX;
		currY = nposY;
		
		for(int y = 0; y < newMap.length; y++)
		{
			
			for(int x = 0; x < newMap[0].length; x++)
			{
				
				open[y][x] = false; //Set the node to not open
				closed[y][x] = false; //Set the node to not closed
				
			}
			
		}
		
		open[currX][currY] = true; //Opens first node
		
		while(currX != ntargetX || currY != ntargetY)
		{
			
			for(int i = 0; i < 4; i++) { //For every neighbour	
				if(i == 0) {	
					if(currY > 0)
						currY--;					
					else	
						continue;	
				} else if(i == 1) {	
					currY++;
					currX++;
				} else if(i == 2) {	
					currX--;
					currY++;	
				} else if(i == 3) {	
					currY--;	
					if(currX > 0)	
						currX--;	
					else	
						continue;	
				}
				
				if(!newMap[currY][currX].equals("#") && !closed[currY][currX]) //If node is walkable and not closed
				{
					
					gCost[currY][currX] = (int) Math.round(Math.sqrt(Math.abs(nposX - currX) + Math.abs(nposY - currY))); //Get gCost (distance from start)
					System.out.println("Current gCost: " + gCost[currY][currX]);
					hCost[currY][currX] = (int) Math.round(Math.sqrt(Math.abs(ntargetX - currX) + Math.abs(ntargetY - currY))); //Get gCost (distance from start)
					System.out.println("Current hCost: " + hCost[currY][currX]);
					fCost[currY][currX] = gCost[currY][currX] + hCost[currY][currX];
					System.out.println("Current fCost: " + fCost[currY][currX]);
					
				}
				
			}
			
			
		
		}
		
		
		
		return null; //Necessary return
	}
	
	static void editArray(int newInt)
	{
		
		int currentSize;
		currentSize = currentPath.length;
			
		int newSize = currentSize + 1;
		int[] tempArray = new int[newSize];
		
		for (int i=0; i < currentPath.length; i++)
	   		tempArray[i] = currentPath[i];
		
		tempArray[newSize - 1] = newInt;
		currentPath = tempArray;
		System.out.println("added " + newInt + " to path");
		
	}
	    
}
